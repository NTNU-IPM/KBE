;;; List created from input files, collecting lists of the points that are to be on the same line in space (2D space for now).
(defvar *line-groups* '())

;;; Constructs a generic collecion-class, used by the different collections
(define-class collection-class
  :inherit-from (object)
  :properties (
               collection-type nil
               )
  )
;;; Checks whether a specific file is accessible or not, if so then execute the corresponding read method
(define-method read-from-file collection-class ()
  (let (
        (file-name (write-to-string !collection-type ))
        (file-path (logical-path (the version-path (:from ^version-selection)) (concatenate file-name ".txt") ) )
        (function-name (read-from-string (concatenate "read-" file-name "-from-file")) )
        )
    (if (and
         file-path
         (stringp file-path)
         (probe-file file-path)
         )
        (with-open-file (file file-path :direction :input)
          (apply function-name (list file))
          )
      (progn
        (message (format nil "\"~a\" is not a valid file path." file-path) :append? t)
        nil
        )
      )
    )
  )
  
;;; Executes the read-from-file method and creates the corresponding subobjects for the constraints
(define-class constraint-collection
  :inherit-from (series-object collection-class)
  :properties (
               ;;Traverse to Superior reference
;;;                point-ref-list nil
			   
			   property-objects-list (list
									  '("Draw all joints" (button1-parameters :draw-joints )
                                        ui-work-area-action-button-class)
									  '("Draw all joints with mating nodes" (button1-parameters :draw-joints-mesh)
                                        ui-work-area-action-button-class)
										""
										'("Undraw" (button1-parameters :undraw)
                                        ui-work-area-action-button-class)
									  )
					
               collection-type 'constraints
               constraint-list (read-from-file !superior)
               quantity (length ^constraint-list)
               class-expression '(read-from-string (concatenate (nth 1 (nth !index !constraint-list)) "-constraint-class"))
               series-prefix 'c
			   
			   init-form '(
                           point-ref 			(nth (nth 0 (nth !index ^constraint-list)) ^point-ref-list)
                           constraint-type 		(nth 1 (nth !index ^constraint-list))
                           link-incidence 		(nth 2 (nth !index ^constraint-list))
                           direction 			(normalize (nth 3 (nth !index ^constraint-list)))
                           constraint-variable	(nth 4 (nth !index ^constraint-list))
						   id 					(+ ^index 1)
                           )
               )
  )
;;; Button actions for drawing joints, with error-handler
(define-method work-area-button1-action constraint-collection (params)
	(case params
		(:draw-joints
			(loop for constraint in ^constraints-ref-list
				do 
				(with-error-handler (:error-message (concatenate "Error drawing " (write-to-string (object-name constraint))) :show-system-error? nil)		
					(let (
							(male (the male-element-solid-model (:from constraint)))
							(female (the female-element-solid-model (:from constraint)))
						)
						(progn
							(change-value (the display? (:from (the joint-center-node (:from male)))) nil)
							(change-value (the display? (:from (the joint-center-node (:from female)))) nil)
							(change-value (the display? (:from (the mating-surface-nodes (:from male)))) nil)
							(change-value (the display? (:from (the mating-surface-nodes (:from female)))) nil)
						)
					)
				(draw constraint))
			)
		)
		(:draw-joints-mesh
			(loop for constraint in ^constraints-ref-list
				do 
				(with-error-handler (:error-message (concatenate "Error drawing " (write-to-string (object-name constraint))) :show-system-error? t)		
					(let (
							(male (the male-element-solid-model (:from constraint)))
							(female (the female-element-solid-model (:from constraint)))
						)
						(progn
							(change-value (the display? (:from (the joint-center-node (:from male)))) t)
							(change-value (the display? (:from (the joint-center-node (:from female)))) t)
							(change-value (the display? (:from (the mating-surface-nodes (:from male)))) t)
							(change-value (the display? (:from (the mating-surface-nodes (:from female)))) t)
						)
					)
				(draw constraint))
			)
		)
		(:undraw
			(undraw self)
		)
	)  
)
;;; Reads each line of the constraints file and adds this to a list 
(defun read-constraints-from-file (stream)
  (when stream
    (loop for line = (read-line stream nil :eof)
      until (equal line :eof)
      for ls = (string-to-delimited-token-list line :delimiter #\tab :string-token? nil)
      for c-data = (list
                    (nth 0 ls) (nth 1 ls) (read-from-string (nth 2 ls)) (read-from-string (nth 3 ls)) (read-from-string (nth 4 ls))
                    )
      collect c-data
      )
    )
  )
;;; Executes the read-from-file and creates the corresponding subobjects for the points
(define-class point-collection
  :inherit-from (series-object collection-class)
  :properties (
               collection-type 	'coordinates
               points-list 		(read-from-file !superior)
               quantity 		(length ^points-list)
               class-expression	'point-data-model
               series-prefix 	'p
               init-form '(
						   label 		(nth 0 (nth ^index ^points-list))
                           coordinates	(list (nth 1 (nth ^index ^points-list)) (nth 2 (nth ^index ^points-list)) (nth 3 (nth ^index ^points-list)))
						   dv-values 	(nth 4 (nth ^index ^points-list))
						   line-group 	(nth 5 (nth ^index ^points-list))
						   is-fixed? 	(nth 6 (nth ^index ^points-list))
						   id 			^index
                           )
               )
  )
;;; Reads each line of the coordinats file and adds this to a list  
(defun read-coordinates-from-file (stream)
  (when stream
    (loop for line = (read-line stream nil :eof)
      until (equal line :eof)
	  for ls = (string-to-delimited-token-list line :delimiter #\tab :string-token? nil)
	  for coord-line = (list
	  (read-from-string (nth 0 ls)) (nth 1 ls) (nth 2 ls) (nth 3 ls) (read-from-string (nth 4 ls)) (read-from-string (nth 5 ls)) (nth 6 ls) )
      collect coord-line
      )
    )
  )
;;; Defines the default properties of each shape
(define-class shape-data-model
  :inherit-from (object)
  :properties (
               label nil
			   link-ref (default 'default)
               sweep-index (default 'default)
               cross-section-type (read-from-string (remove "-section" (write-to-string (default 'circular-section))))
               solid-dimensions '(0.04 0.04)
               point-list nil
               weight-list nil
               )
  )

;;; Executes the read-from-file method and creates the corresponding subobjects for the shapes
(define-class shape-collection
  :inherit-from (series-object collection-class)
  :properties (
;;;                points-list (FORMATTED-list-FROM-FILE (logical-path MECHANISM-LIBRARY "coordinates.txt") :element-format '(x y z))
               collection-type 'shapes
               shapes-list (read-from-file !superior)
               quantity (length ^shapes-list)
               class-expression 'shape-data-model
               series-prefix 'shape
               init-form '(
						   label 				(nth 0 (nth ^index ^shapes-list))
                           link-ref 			(nth 1 (nth ^index ^shapes-list))
                           sweep-index 			(nth 2 (nth ^index ^shapes-list))
                           cross-section-type 	(nth 3 (nth ^index ^shapes-list))
                           solid-dimensions 	(nth 4 (nth ^index ^shapes-list))
                           point-list 			(nth 5 (nth ^index ^shapes-list))
                           weight-list 			(nth 6 (nth ^index ^shapes-list))
                           )
               )
  )

;;; Reads each line of the shapes file and adds this to a list 
(defun read-shapes-from-file (stream)
;;;   (with-open-file (file (logical-path (the path (:from ^mechanism-selection) ) "shapes.txt") :direction :input)
 (when stream
   (loop for line = (read-line stream  nil :eof)
     until (equal line :eof)
     for ls = (string-to-delimited-token-list line :delimiter #\tab :string-token? nil)
     for shape-data = (list
                       (read-from-string(nth 0 ls)) (nth 1 ls) (nth 2 ls) (read-from-string (nth 3 ls)) (read-from-string (nth 4 ls)) (read-from-string (nth 5 ls)) (read-from-string (nth 6 ls))
                       )
     collect shape-data
     )
   )
 )
;;; Creates all the links in the object tree
(define-class link-collection
  :inherit-from (series-object)
  :properties (
               (cross-section-type :class 'option-property-class
                   label "Cross-section Type"
                   mode 'menu
                   formula (nth 0 !options-list)
				   
				   ;Returns all classes that inherits from section-model, i.e. all cross-sections
                   options-list (reverse (class-direct-defined-subclasses 'section-model))
                   labels-list (loop for option in !options-list
                                 collect (remove "-section" (write-to-string option))
                                 )
                   )
               common-width 0.04
               common-height 0.04
               property-objects-list (list
					(the superior cross-section-type self) 
					'("Set all cross-sections" (button1-parameters :set-c button3-parameters :unset)
					ui-work-area-action-button-class)
					
					(the superior common-width self)
					(the superior common-height self) 
					'("Set all dimensions" (button1-parameters :set-d button3-parameters :unset)
					ui-work-area-action-button-class)
					""
					'("Draw all link members" (button1-parameters :draw-without-mesh button3-parameters :draw-without-mesh)
					ui-work-area-action-button-class)
					'("Draw all link members with mesh" (button1-parameters :draw-with-mesh button3-parameters :draw-with-mesh)
					ui-work-area-action-button-class)
					""
					'("Undraw" (button1-parameters :undraw button3-parameters :unset)
					ui-work-area-action-button-class)
				)
               ;;Traverse to Superior reference
;;;                point-ref-list nil
;;;                constraints-ref-list nil
               link-list (sort (copy-seq (remove-duplicates (append-list (loop for kid in (the constraints-ref-list) 
                                                                 collect (the link-incidence (:from kid)) 
                                                                 )
                                                               ))
                                        ) '<)
 
               (init-default-shape :class 'shape-data-model
                   )
               
               default-shape (let(
                                  (def (loop for shape in (children ^^shapes :class 'shape-data-model)
                                         when (equal 'default (the link-ref (:from shape)))
                                         do (return shape)
                                         ) )
                                  )
                               (if def def ^init-default-shape)
                               )
               
               quantity (length ^link-list)
               class-expression 'link-model-class
               series-prefix 'link
               init-form '(
                           link-index (nth ^index ^^link-list)
                           constraints-incident-on-link-list (loop for kid in (the constraints-ref-list)
                                                               for con = (get-constraint-incidence kid ^link-index)
                                                               when con collect con
                                                               )
                           )
               )
  )
;;; Gets the link reference from a link-collection
(define-method get-link-ref link-collection (link-index)
  (nth (position link-index !link-list) ^link-ref-list)
  )
;;; Button actions for drawing/undrawing links (with and without mesh),
;;; setting cross-section-type and setting dimensions  
(define-method work-area-button1-action link-collection (params)
	(case params
		(:set-c
			(loop for l in ^link-ref-list do
				(loop for s in (the members-ref-list (:from (the link-solid-geometry (:from l)) )) do
					(change-value (the cross-section-type self (:from s)) !cross-section-type)
				)
			)
		)
		(:set-d
			(loop for l in ^link-ref-list
				do (loop for s in (the members-ref-list (:from (the link-solid-geometry (:from l)) ))
					do (change-value (the width self (:from s)) !common-width)
					(change-value (the height self (:from s)) !common-height)
				)
			)
		)
		(:draw-without-mesh
			(loop for link in ^link-ref-list
				do (loop for member in (the visible-members-ref-list (:from (the link-solid-geometry (:from link)) ))
					do (draw member :draw-subobjects? nil )
				)
			)
		)
		(:undraw
			(undraw self)
		)
		(:draw-with-mesh
			(draw self)
		)
	)
	
)
;;; Defines the data-model for folders
(define-class folder-info-model
  :inherit-from (series-object)
  :properties (
               path nil
               folder (subseq (remove #MECHANISM-LIBRARY# ^path) 1)
               label (replace (copy-seq ^folder) " " :start1 (position "-" ^folder :test 'string-equal) )

               class-name (let (
                                (name (read-from-string (concatenate ^folder "-class" ) ))
                                )
                            (when (find-class name)
                              name
                              )
                            )
				
				version-list (rest (rest (directory ^path)))
				class-expression 'mechanism-version-info
				series-prefix 'version
				quantity (length ^version-list)
				init-form '(
							version-path (nth ^index ^^version-list)
							version-name (subseq (remove ^^path ^version-path) 1)
						    )
               )
  )
  
(define-class mechanism-version-info 
	:inherit-from (object)
	:properties (
				 version-path nil				 
				 version-name nil
				 )
	)
  
;;; Reads all subfolders of the library folder in the file system and creates a subobject for each folder 
;;; as a series-object of the type folder-info-model
(define-class folder-collection
  :inherit-from (series-object)
  :properties (
               
               ;; Removing ../ and ./
			   ;; Returns a list of the contents in the library directory
               library-subfolder-list (rest (rest (directory #mechanism-library#)) )
               quantity (length ^library-subfolder-list)
               class-expression 'folder-info-model
               series-prefix 'folder
               init-form '(
                           path (nth ^index ^^library-subfolder-list)
                           )
               )
  )
 
(define-class design-variable-class
	:inherit-from (object)
	:properties (
				 dv-name nil
				 direction nil
				 line-name nil
				 points-on-line nil
				 affected-translation-coords-list nil
				 coord-pos (position 1 ^direction)
				 
				 (dv-value :class 'editable-data-property-class
					formula (nth ^coord-pos (the coordinates (:from  (nth (nth 0 ^affected-translation-coords-list) ^point-ref-list))))
					label ^dv-name
					)
				 
				 property-objects-list (list 
										 (list (the superior dv-value self)
												'(automatic-apply? t))
										 '("Update design variable changes" (button1-parameters :update-dvs)
											ui-work-area-action-button-class)
										)
				 )
	)
	
	
	
(define-method work-area-button1-action design-variable-class (params)
	(case params
		(:update-dvs
			(progn 
				(loop for id in !affected-translation-coords-list do 
					(setq (nth !coord-pos (the coordinates (:from (nth id ^point-ref-list)))) !dv-value)
				)
				(loop for id in !points-on-line do
					;(setq (the coordinates (:from (nth id ^point-ref-list))) )
				)
			)
		)
	)
)

(defun get-new-dv-coords-from-line (fixed-point dv1 dv2 direction)
	(if (= (nth 0 direction) 1)
		(list 
		 (+ (nth 0 dv1) (* (/ (- (nth 0 fixed-point) (nth 0 dv1)) (- (nth 1 fixed-point) (nth 1 dv1)) ) (- (nth 1 dv2) (nth 1 dv1)) ))
		 (nth 1 dv2)
		 (nth 2 dv2)
		)
		(list
		 (nth 0 dv2)
		 (+ (nth 1 dv1) (* (/ (- (nth 1 fixed-point) (nth 1 dv1)) (- (nth 0 fixed-point) (nth 0 dv1)) ) (- (nth 0 dv2) (nth 0 dv1)) ))
		 (nth 2 dv2)
		)
	)
)


(define-class design-variables-collection 
	:inherit-from (series-object collection-class)
	:properties (
				 collection-type 'design-variables
				 dv-list (read-from-file !superior)
				 quantity (length ^dv-list)
				 series-prefix 'dv
				 class-expression 'design-variable-class
				 init-form '(
							 type (nth 0 (nth ^index ^dv-list))
							 dv-name (nth 0 (nth ^index ^dv-list))
							 direction (nth 1 (nth ^index ^dv-list))
							 ;; TODO: Handle the possibility of more than one group of points on a line
							 line-name (nth 0 (remove-duplicates (remove nil 
												(loop for point-entry in ^^point-ref-list
													if (the dv-values (:from point-entry)) 
														append (loop for dv in (the dv-values (:from point-entry))
															if (and (string-equal (string dv) (string ^dv-name)) (the line-group (:from point-entry)))
																collect (the line-group (:from point-entry))
															)
														)
													)
												))
											
							 points-on-line (remove nil 
												(loop for point-entry in ^^point-ref-list
													if (string-equal ^line-name (the line-group (:from point-entry)))
														collect (list (the id (:from point-entry)) (the is-fixed? (:from point-entry)) )
													)
												)
												
							 affected-translation-coords-list 
									(remove nil (loop for point-entry in ^^point-ref-list
										if (the dv-values (:from point-entry))
											 append (loop for dv in (the dv-values (:from point-entry))
												if (string-equal (string dv) (string ^dv-name))
													collect (the id (:from point-entry))
												 )
										)
									)
                             )
				 )
	 )

 
(defun read-design-variables-from-file (stream)
	(when stream
		(loop for line = (read-line stream  nil :eof)
			until (equal line :eof)
			for ls = (string-to-delimited-token-list line :delimiter #\tab :string-token? nil)
			for design-data = (list (read-from-string (nth 0 ls)) (read-from-string (nth 1 ls)) )
			collect design-data
			)
		)
   )
  
;;; Creates the different collections (constraint, point, link, shape and meshdb) as subobjects
(define-class mechanism-collection
  :inherit-from (data-model-node-mixin)
  :properties (
               point-ref-list (children ^points :class 'point-data-model )
			   build (remove nil(loop for point in ^point-ref-list
							do collect (add-point-to-line-group point)
							)
						)
						
               constraints-ref-list (children ^constraints :class 'master-joint-model)
               link-ref-list (children ^links :class 'link-model-class)
			   
			   drawable-link-ref-list (loop for link in ^link-ref-list
										if (the is-link-drawable? (:from link)) 
											collect link)
											
			   non-open-constraints-list (when ^constraints-ref-list
											  (loop for constraint in ^constraints-ref-list do
												  if (not (string-equal "open" (get-constraint-type constraint)))
													  collect constraint
											  )
										  )
			   
			   dv-ref-list (children ^design-variables :class 'design-variable-class)
			   ;a (add-point-to-line-group (nth 1 ^point-ref-list))

			   
			   ;; mechanism-selection is a list of folder-info-models
               (mechanism-selection :class 'option-property-class
                   labels-list (loop for subfolder in (children ^folders :class 'folder-info-model)
                                when (the path (:from subfolder))
                                collect (the label (:from subfolder))
                                )
                   options-list (children ^folders :class 'folder-info-model)
                   mode 'menu
                   formula (nth (position "four bar" !labels-list) !options-list)
				   label "Select Mechanism"
                   )
				   
			   (version-selection :class 'option-property-class
					options-list (children ^^mechanism-selection :class 'mechanism-version-info)
					labels-list (loop for version in !options-list
									collect (the version-name (:from version))
									)
					mode 'menu
					formula (nth 0 !options-list)
					;formula (nth (- (length !options-list) 1) !options-list)
					label "Select Version"
					)
					
			   (dv :class 'data-matrix-property-class
					label "Edit design variables"
					mode 'pop-up
					columns-labels-list (list "Value")
					rows-labels-list (loop for dv in ^dv-ref-list
						collect (string (the dv-name (:from dv)))
						)
					formula (loop for dv in ^dv-ref-list
						collect (list (the dv-value (:from dv)))
						)
					)
			   
			   ;dv :class 'option-property-class
				;	;options-list ^dv-ref-list
				;	mode 'menu
				;	options-list (loop for dv in ^dv-ref-list
				;		collect (the dv-name (:from dv))
				;		)
				;	;formula (the dv-name (:from (nth 0 ^dv-ref-list)))
				;	)
			   
			   property-objects-list (list 
											(list (the superior mechanism-selection self) 
												'(automatic-apply? t))
											(list (the superior version-selection self) 
												'(automatic-apply? t))
											""
											'("Draw mechanism" (button1-parameters :draw-sewn-wo-mesh)
											ui-work-area-action-button-class)
											'("Draw mechanism with 3D mesh" (button1-parameters :draw-sewn-with-tet-mesh)
											ui-work-area-action-button-class)
											'("Draw mechanism with 2D mesh" (button1-parameters :draw-sewn-with-tri-mesh)
											ui-work-area-action-button-class)
											""
											'("Undraw" (button1-parameters :undraw button3-parameters :unset)
											ui-work-area-action-button-class)
											'("Export to FEDEM" (button1-parameters :bdf-export)
											ui-work-area-action-button-class)
											(list (the superior dv self)
												'(automatic-apply? t))
                                     )
               
               ;;Property storing folders from library
               (folders :class 'folder-collection
                   )

			   ;write-to-file (write-save-fedem-solver !superior)
			   
			   dv1 (the test-dv (:from (nth 1 ^point-ref-list)))
			   dv2 (the test-dv (:from (nth 3 ^point-ref-list)))
			   			   
			   
			   objective-function (when (probe-file "C:\\Users\\ander_000\\Documents\\KBE\\rasmus\\library\\four-bar\\line\\dummy.txt")
									(+ (the coord-ref (:from (nth 1 ^point-ref-list))) (the coord-ref (:from (nth 3 ^point-ref-list))))
									)
			   
			   p (the version-path (:from ^version-selection))
			   mechanism-type (the folder (:from ^mechanism-selection))
               )
  :subobjects (
               (constraints :class 'constraint-collection
                   )
               (points :class 'point-collection
                   )
               (links :class 'link-collection
                   )
               (shapes :class 'shape-collection
                   )
               (design-variables :class 'design-variables-collection
					)
               (mesh-database :class 'meshdb-class
                   )
               )
  )

  
;(define-method add-point-to-line-group mechanism-collection ()
;	(let (
;		  (line-groups-list '() )
;		  (group-names '() )
;		  )
;		 
;			(loop for point in !point-ref-list
;			if (the line-group (:from point))
;				do (and
;					(append group-names (the line-group (:from point)))
;					(append line-groups-list (list (the line-group (:from point)) (list point)))
;				)
;			)
;			line-groups-list
;		 
;	)
;)
 
(define-method get-drawable-links mechanism-collection ()
	(when !drawable-link-ref-list
		!drawable-link-ref-list)
)
 

(define-method get-mechanism-type mechanism-collection ()
	(the mechanism-selection label)
)
 
(defun add-point-to-line-group (point)
	(if (the line-group (:from point))
		(if (not *line-groups*) ;; Empty list check
			(append *line-groups* (list (the line-group (:from point)) (list point)))
			(loop for group in *line-groups*
				if (= (the line-group (:from point)) (nth 0 group))
					do (append (nth 1 group) point)
					do (append *line-groups* (list (the line-group (:from point)) (list point)))
			)
		)
	)
)

  
(define-method work-area-button1-action mechanism-collection (params)
	(case params

		(:draw-sewn-wo-mesh
			(loop for link in !link-ref-list do
				(with-error-handler (:error-message (concatenate "Error drawing "(write-to-string (object-name link))) :show-system-error? t)
					(draw (the link-solid-geometry (:from link)) :draw-subobjects? nil)
				)
			)
		)
		(:draw-sewn-with-tet-mesh
			(loop for link in !link-ref-list do
				(with-error-handler (:error-message (concatenate "Error drawing "(write-to-string (object-name link))) :show-system-error? t)
					(draw (the link-mesh-model tet-mesh elements-query (:from link)))
				)
			)
		)
		(:draw-sewn-with-tri-mesh
			(loop for link in !link-ref-list do
				(with-error-handler (:error-message (concatenate "Error drawing "(write-to-string (object-name link))) :show-system-error? t)
					(draw (the link-mesh-model link-mesh elements-query (:from link)))
				)
			)
		)
		(:undraw
			(undraw self)
		)
		(:bdf-export
			(loop for link in !drawable-link-ref-list do
				(the analysis nastran-interface run-nastran@ (:from link))
				finally (write-fmm-model-file (the))
			)
		)
	)
)

(define-method write-fmm-model-file mechanism-collection ()
	(let (
		  (baseID 2)
		  (linkID 0)
		  (conID 0)
		  )
		(with-open-file (stream (logical-path (the version-path (:from !version-selection)) (concatenate "model" ".fmm") )
							  :direction :output
							  :if-exists :overwrite
							  )
			(progn 
				(write-static-top-part-to-fmm stream)
				(loop for link in !drawable-link-ref-list do
					(setf baseID (1+ baseID))
					(setf linkID (1+ linkID))
					(format stream "LINK~%")
					(format stream "{~%")
					(format stream "BASE_ID = ~d;~%" baseID)
					(format stream "COLOR = ~,2f ~,2f ~,2f;~%" (random 1.0) (random 1.0) (random 1.0))
					(format stream "COORDINATE_SYSTEM = ~%")
					(format stream "1.00000000 0.00000000 0.00000000 0.00000000~%")
					(format stream "0.00000000 1.00000000 0.00000000 0.00000000~%")
					(format stream "0.00000000 0.00000000 1.00000000 0.00000000;~%")
					(format stream "ID = ~d;~%" linkID)
					(format stream "LINE_COLOR = 1 1 1;~%")
					(format stream "MASS_PROP_DAMP = 0;~%")
					(format stream "ORIGINAL_FE_FILE = ~a;~%" (concatenate "\""
						(logical-path :nastran-data)
						(the analysis nastran-interface model-name (:from link)) "\\"
						(the analysis nastran-interface nastran-file-name (:from link)) "\"")
					)
					(format stream "POLYS_ON_POINTS_OFF = true;~%")
					(format stream "STIF_PROP_DAMP = 0;~%")
					(format stream "USE_MASS_CALCULATION = true;~%")
					(format stream "}~3%")
					
					(let (
						  (number-of-nodes 	(length (get-tet-mesh-entities-list (the link-mesh-model (:from link)))))
						  (counter 			0)
						  )
						(loop for constraint in (get-non-open-constraints-incident-on-link-list link) do
							(setf baseID (1+ baseID))
							(setf counter (1+ counter))
							(write-triad-to-fmm stream constraint baseID linkID (+ number-of-nodes counter))
						)
					)
				)
				(loop for constraint in !non-open-constraints-list do
					(setf baseID (1+ baseID))
					(setf conID (1+ conID))
					(let (
						  (triadID 				(get-male-triad-id-from-master-joint-model constraint))
						  (is-male-drawable? 	(the male-element-solid-model is-incident-link-drawable? (:from constraint)))
						  (is-female-drawable?	(the female-element-solid-model is-incident-link-drawable? (:from constraint)))
						  )
						 ;;Case 1: male element has a drawable link, female does not. 
						 ;;Master triad is the ground, slave triad is the male element
						 (if (and is-male-drawable? (not is-female-drawable?))
							(progn 
								(write-joint-type-to-fmm stream constraint baseID conID (1+ triadID) triadID)
								(setf baseID (1+ baseID))
								(write-triad-to-fmm stream (the female-element-solid-model (:from constraint)) baseID -1 -1) ;;In FEDEM, -1 means that it's fixed to the ground
							)
							;;Case 2: female element has a drawable link, male does not
							;;Master triad is the ground, slave triad is the female element
							(if (and is-female-drawable? (not is-male-drawable?))
								(progn
									(write-joint-type-to-fmm stream constraint baseID conID triadID (1+ triadID))
									(setf baseID (1+ baseID))
									(write-triad-to-fmm stream (the male-element-solid-model (:from constraint)) baseID -1 -1)
								)
								;;Case 3: both elements have drawable links
								;;Master triad is the male element, slave triad is the female element
								;;No extra ground triad has to be created
								(write-joint-type-to-fmm stream constraint baseID conID triadID (1+ triadID))
							)
						)
					)
				)
				(setf baseID (1+ baseID))
				(write-analysis-properties-to-fmm !mechanism-type stream baseID)
				(format stream "END {FEDEMMODELFILE}")
			)
		)
	)
)

(defun write-static-top-part-to-fmm (stream)
	(progn 
		(format stream "FEDEMMODELFILE {R7.0.4 ASCII}~2%")
		
		(format stream "GLOBAL_VIEW_SETTINGS~%{~%")
		(format stream "ID = 1;~%")
		(format stream "SYMBOL_SCALE = 0.1;~%")
		(format stream "SYMBOL_LINE_WIDTH = 1;~%")
		(format stream "BACKGROUND_COLOR = 0.098039 0.305882 0.458823;~%")
		(format stream "CAMERA_FOCAL_DIST = 0.707107;~%")
		(format stream "CAMERA_HEIGHT = 1.41421;~%")
		(format stream "CAMERA_ORIENTATION =~%")
		(format stream "1.00000000 0.00000000 0.00000000 0.00000000~%")
		(format stream "0.00000000 1.00000000 0.00000000 0.00000000~%")
		(format stream "0.00000000 0.00000000 1.00000000 0.70710678;~%}~2%")
		
		(format stream "MECHANISM~%{~%")
		(format stream "ID = 1;~%")
		(format stream "BASE_ID = 1;~%") ;;Manually setting "static" base ID
		(format stream "GRAVITY = 0 0 -9.81;~%") ;;When gravity changes, let me know. Also update this value.
		(format stream "POSITION_TOLERANCE = 0.0001;~%}~2%")
		
		(format stream "REF_PLANE~%{~%")
		(format stream "ID = 1;~%")
		(format stream "BASE_ID = 2;~%") ;;Manually setting "static" base ID
		(format stream "HEIGHT = 0.1;~%")
		(format stream "WIDTH = 0.1;~%")
		(format stream "COLOR = 1 1 1;~%")
		(format stream "TRANSPARENCY = 0.65;~%}~3%")
	)
)

(defun write-triad-to-fmm (stream constraint baseID linkID node-number)
	(progn
		(format stream "TRIAD~%{~%")
		(format stream "BASE_ID = ~d;~%" baseID)
		(format stream "ID = ~d;~%" (get-joint-element-id constraint))
		(format stream "COORDINATE_SYSTEM = ~%")
		(format stream "1.0 0.0 0.0 ~d~%" (get-main-frame constraint 0))
		(format stream "0.0 1.0 0.0 ~d~%" (get-main-frame constraint 1))
		(format stream "0.0 0.0 1.0 ~d;~%" (get-main-frame constraint 2))
		(format stream "LOCAL_DIRECTIONS = GLOBAL;~%")
		(format stream "LOCATION3D_DATA = CART_X_Y_Z  EUL_Z_Y_X;~%")
		(format stream "OWNER_LINK = ~d;~%" linkID)
		(format stream "FE_NODE_NO = ~d;~%" node-number)
		(format stream "NDOFS = 6;~%}~3%")
	)
)

(defun write-joint-type-to-fmm (stream constraint baseID conID masterID slaveID)
	
	(if (equal "revolute" (get-constraint-type constraint))
		(progn 
				(format stream "~a~%{~%" "REV_JOINT")
				(format stream "BASE_ID = ~d;~%" baseID)
				
				;;Calculating rotation matrix with respect to rotation angle and rotation axis
				(format stream "COORDINATE_SYSTEM = ~%")
				(format stream "~d ~d ~d 0.0~%" (+ (cosd((get-rot-angle constraint))) 
						(* (expt (nth 0 (get-unit-vector constraint)) 2) (- 1 (cosd((get-rot-angle constraint))))))
						
					(- (* (nth 0 (get-unit-vector constraint)) (nth 1 (get-unit-vector constraint)) (- 1 (cosd((get-rot-angle constraint)))))
					(* (nth 2 (get-unit-vector constraint)) (sind((get-rot-angle constraint)))))
					
					(+ (* (nth 0 (get-unit-vector constraint)) (nth 2 (get-unit-vector constraint)) (- 1 (cosd((get-rot-angle constraint)))))
						(* (nth 1 (get-unit-vector constraint)) (sind((get-rot-angle constraint))))))
				
				(format stream "~d ~d ~d 0.0~%"
					(+ (* (nth 1 (get-unit-vector constraint)) (nth 0 (get-unit-vector constraint)) (- 1 (cosd((get-rot-angle constraint)))))
						(* (nth 2 (get-unit-vector constraint)) (sind((get-rot-angle constraint)))))
					
					(+ (cosd((get-rot-angle constraint))) 
						(* (expt (nth 1 (get-unit-vector constraint)) 2) (- 1 (cosd((get-rot-angle constraint))))))
				
					(- (* (nth 1 (get-unit-vector constraint)) (nth 2 (get-unit-vector constraint)) (- 1 (cosd((get-rot-angle constraint)))))
						(* (nth 0 (get-unit-vector constraint)) (sind((get-rot-angle constraint))))))
				
				(format stream "~d ~d ~d 0.0;~%"
					(- (* (nth 2 (get-unit-vector constraint)) (nth 1 (get-unit-vector constraint)) (- 1 (cosd((get-rot-angle constraint)))))
						(* (nth 1 (get-unit-vector constraint)) (sind((get-rot-angle constraint)))))
						
					(+ (* (nth 2 (get-unit-vector constraint)) (nth 1 (get-unit-vector constraint)) (- 1 (cosd((get-rot-angle constraint)))))
						(* (nth 0 (get-unit-vector constraint)) (sind((get-rot-angle constraint)))))
						
					(+ (cosd((get-rot-angle constraint))) 
						(* (expt (nth 2 (get-unit-vector constraint)) 2) (- 1 (cosd((get-rot-angle constraint)))))))
							
				(format stream "HAS_Z_TRANS_DOF = false;~%")
				(format stream "ID = ~a;~%" conID)
				(format stream "LOCATION3D_DATA = CART_X_Y_Z  EUL_Z_Y_X;~%")
				(format stream "MASTER_TRIAD = ~d;~%" masterID)
				(format stream "MOVE_MASTER_TRIAD_ALONG = false;~%")
				(format stream "MOVE_SLAVE_TRIAD_ALONG = false;~%")
				(format stream "ROT_FORMULATION = FOLLOWER_AXIS;~%")
				(format stream "ROT_SEQUENCE = ZYX;~%")
				(format stream "ROT_SPRING_CPL = NONE;~%")
				(format stream "SLAVE_TRIAD = ~d;~%" slaveID)
				(format stream "TRAN_SPRING_CPL = NONE;~%")
				(format stream "VAR_QUADRANTS = 0 0 0;~%")
				(format stream "Z_ROT_STATUS = FREE;~%")
				(format stream "Z_TRANS_STATUS = FREE;~%}~3%")
		)
		(if (equal "spheric" (get-constraint-type constraint))
			(progn 
					(format stream "~a~%{~%" "BALL_JOINT")
					(format stream "BASE_ID = ~d;~%" baseID)
					
					;;Calculating rotation matrix with respect to rotation angle and rotation axis
					(format stream "COORDINATE_SYSTEM = ~%")
					(format stream "~d ~d ~d 0.0~%" (+ (cosd((get-rot-angle constraint))) 
							(* (expt (nth 0 (get-unit-vector constraint)) 2) (- 1 (cosd((get-rot-angle constraint))))))
							
						(- (* (nth 0 (get-unit-vector constraint)) (nth 1 (get-unit-vector constraint)) (- 1 (cosd((get-rot-angle constraint)))))
						(* (nth 2 (get-unit-vector constraint)) (sind((get-rot-angle constraint)))))
						
						(+ (* (nth 0 (get-unit-vector constraint)) (nth 2 (get-unit-vector constraint)) (- 1 (cosd((get-rot-angle constraint)))))
							(* (nth 1 (get-unit-vector constraint)) (sind((get-rot-angle constraint))))))
					
					(format stream "~d ~d ~d 0.0~%"
						(+ (* (nth 1 (get-unit-vector constraint)) (nth 0 (get-unit-vector constraint)) (- 1 (cosd((get-rot-angle constraint)))))
							(* (nth 2 (get-unit-vector constraint)) (sind((get-rot-angle constraint)))))
						
						(+ (cosd((get-rot-angle constraint))) 
							(* (expt (nth 1 (get-unit-vector constraint)) 2) (- 1 (cosd((get-rot-angle constraint))))))
					
						(- (* (nth 1 (get-unit-vector constraint)) (nth 2 (get-unit-vector constraint)) (- 1 (cosd((get-rot-angle constraint)))))
							(* (nth 0 (get-unit-vector constraint)) (sind((get-rot-angle constraint))))))
					
					(format stream "~d ~d ~d 0.0;~%"
						(- (* (nth 2 (get-unit-vector constraint)) (nth 1 (get-unit-vector constraint)) (- 1 (cosd((get-rot-angle constraint)))))
							(* (nth 1 (get-unit-vector constraint)) (sind((get-rot-angle constraint)))))
							
						(+ (* (nth 2 (get-unit-vector constraint)) (nth 1 (get-unit-vector constraint)) (- 1 (cosd((get-rot-angle constraint)))))
							(* (nth 0 (get-unit-vector constraint)) (sind((get-rot-angle constraint)))))
							
						(+ (cosd((get-rot-angle constraint))) 
							(* (expt (nth 2 (get-unit-vector constraint)) 2) (- 1 (cosd((get-rot-angle constraint)))))))
							
					(format stream "FRICTION_DOF = 3;~%")
					(format stream "ID = ~d;~%" conID)
					(format stream "LOCATION3D_DATA = CART_X_Y_Z  EUL_Z_Y_X;~%")
					(format stream "MASTER_TRIAD = ~d;~%" masterID)
					(format stream "MOVE_MASTER_TRIAD_ALONG = false;~%")
					(format stream "MOVE_SLAVE_TRIAD_ALONG = false;~%")
					(format stream "ROT_FORMULATION = FOLLOWER_AXIS;~%")
					(format stream "ROT_SEQUENCE = ZYX;~%")
					(format stream "ROT_SPRING_CPL = NONE;~%")
					(format stream "SLAVE_TRIAD = ~d;~%" slaveID)
					(format stream "TRAN_SPRING_CPL = NONE;~%")
					(format stream "VAR_QUADRANTS = 0 0 0;~%")
					(format stream "X_ROT_STATUS = FREE;~%")
					(format stream "Y_ROT_STATUS = FREE;~%")
					(format stream "Z_ROT_STATUS = FREE;~%}~3%")
			)
		)
	)
)

(defun write-analysis-properties-to-fmm (mechanism-type stream baseID)
	(format stream "ANALYSIS~%{~%")
	(format stream "ID = 1;~%")
	(format stream "BASE_ID = ~d;~%" baseID)
	(format stream "START_TIME = 0;~%")
	(if (equal "four-bar" mechanism-type)
		;;If true:
		(progn 
			(format stream "END_TIME = 2.5;~%")
			(format stream "TIME_INCR = 0.01;~%")
			(format stream "STATIC_EQL_TOLERANCE = 0.001;~%")
			(format stream "VELOCITY_PROP_TOLERANCE = 0;~%")
			(format stream "INITIAL_EQL_ITERATIONS = false;~%")
			(format stream "USE_NEWMARK_DAMPING = true;~%")
			(format stream "USE_MASS_CORRECTION = false;~%")
			(format stream "MIN_TIME_INCREMNT = 0.001;~%")
			(format stream "SOLVE_EIGENVALUES = false;~%")
			(format stream "EIGENVALUE_SOLUTION_TIME_INTERVAL = 0.1;~%")
			(format stream "IGNORE_TOLERANCE = false;~%")
			(format stream "FORCE_NUM_IT = 5;~%")
			(format stream "MINIMUM_NUM_IT = 1;~%")
			(format stream "MAX_NUM_IT = 15;~%")
			(format stream "MIN_MATRIX_UPDATE = 5;~%")
			(format stream "STEP_REDUCTION_FACTOR = 1;~%")
			(format stream "EQ_OPTIONS= 0;~%")
			(format stream "RESTART_OPTIONS = 0;~%")
			(format stream "RESULT_OPTIONS = 0;~%")
			(format stream "EIGENVALUE_OPTIONS = 0;~%")
			(format stream "STRESS_START_TIME = 0;~%")
			(format stream "STRESS_STOP_TIME = 1;~%")
			(format stream "STRESS_TIME_INCR = 0.1;~%")
			(format stream "STRESS_DEFORMATIONS_ONLY = false;~%}~3%")
			
			;;Engines
			(let (
				  (descr (list "\"Torque\"" "\"Reference\"" "\"Joint Velocity\""))
				  (sensor (list "3 FcSIMPLE_SENSOR" "1 FcSIMPLE_SENSOR" "2 FcSIMPLE_SENSOR"))
				  (math-func (list "1 FcfSCALE" "1 FcfLIM_RAMP" "1 FcfSCALE"))
				  (entity (list -1 -1 6))
				  (dof (list -1 -1 5))
				  )
				 (loop for i from 0 to 2 do
					(setf baseID (1+ baseID))
					(write-engines-to-fmm stream baseID (1+ i) (nth i descr) (nth i sensor) 
						(nth i math-func) (nth i entity) (nth i dof))
				 )
			)
			
			;;Sensors
			(let (
				  (descr (list "\"Time sensor\"" "\"\"" "\"Control output sensor\""))
				  (measured (list "1 FcTIME" "1 FcREV_JOINT" "1 FccOUTPUT"))
				  )
				 (loop for i from 0 to 2 do
					(setf baseID (1+ baseID))
					(write-sensors-to-fmm stream baseID (1+ i) (nth i descr) (nth i measured))
				 )
			)
			
			;;Loads. Sould make a generic function out of this too
			(setf baseID (1+ baseID))
			(format stream "LOAD~%{~%")
			(format stream "BASE_ID = ~d;~%" baseID)
			(format stream "ID = 1;~%")
			(format stream "ENGINE = 1 FcENGINE;~%")
			(format stream "OWNER_TRIAD = ~d;~%" 'leggeTilOwnerHer)
			(format stream "LOAD_TYPE = 1;~%")
			(format stream "INIT_LOAD = 0;~%")
			(format stream "SCALE_LOAD = 1;~%")
			(format stream "FROM_OBJECT = -1 FcLINK;~%")
			(format stream "FROM_POINT = 0 0 0;~%")
			(format stream "TO_OBJECT = -1 FcLINK;~%")
			(format stream "TO_POINT = 0 0 0.1;~%}~3%")
			
			;;Function definitions
			(setf baseID (1+ baseID))
			(format stream "FUNC_SCALE~%{~%")
			(format stream "BASE_ID = ~d;~%" baseID)
			(format stream "ID = 1;~%")
			(format stream "SCALE = 1;~%}~2%")
			
			(setf baseID (1+ baseID))
			(format stream "FUNC_LIM-RAMP~%{~%")
			(format stream "BASE_ID = ~d;~%" baseID)
			(format stream "ID = 1;~%")
			(format stream "AMPLITUDE_DISPLACEMENT = 0;~%")
			(format stream "SLOPE_OF_RAMP = 12.5664;~%")
			(format stream "DELAY_OF_RAMP = 0;~%")
			(format stream "END_OF_RAMP = 0.5;~%}~3%")
			
			;;Control lines
			(let (
				  (ownerStart	(list "1 FccINPUT" "2 FccINPUT" "1 FccCOMPARATOR" "1 FccAMPLIFIER"))
				  (ownerEnd 	(list "1 FccCOMPARATOR 1" "1 FccCOMPARATOR 2" "1 FccAMPLIFIER 1" "1 FccOUTPUT 1"))
				  (ful 			(list 2 1 2 2))
				  (controlNo 	(list 1 2 4 3))
				  )
				 (loop for i from 0 to 3 do
					(setf baseID (1+ baseID))
					(write-control-lines-to-fmm stream baseID (1+ i) 
						(nth i ownerStart) (nth i ownerEnd) (nth i ful) (nth i controlNo))
				 )
			)
			
			;;Control i/o
			(let (
				  (name (list "CONTROL_INPUT" "CONTROL_INPUT" "CONTROL_OUTPUT" "CONTROL_AMPLIFIER" "CONTROL_COMPARATOR"))
				  (IDs (list 1 2 1 1 1))
				  (engine (list "2 FcENGINE" "3 FcENGINE" "0 0" "0 0" "0 0"))
				  (position (list "-3.5 1 0" "-3.5 0 0" "2.5 0.5 0" "0.5 0.5 0" "-1.5 0.5 0"))
				  )
				 (loop for i from 0 to 4 do
					(setf baseID (1+ baseID))
					(write-control-io-to-fmm stream (nth i name) baseID (nth i IDs)
						(nth i engine) (nth i position) (if (= i 3) 1))
				 )
			)
			
			;;Graphs
			(let (
				  (descr (list "Motor torque" "x-acceleration " "Motor velocity" "Tip placement"))
				  (title (list "Motor torque [Nm]" "x-acceleration [m/sec2]" "Motor velocity [rad/sec]" "Tip Placement"))
				  )
				 (loop for i from 0 to 3 do
					(setf baseID (1+ baseID))
					(write-graph-definitions-to-fmm stream baseID (nth i descr) (1+ i) (nth i title))
				 )
			)
			
			;;Curves. Need to set triad ids!!!!
			(let (
				  (descr (list "\"Set 0\"" "\"Set 0\"" "\"Set 0\"" "\"Tip placement\""))
				  (x-result (list "<\"SCALAR\",\"Physical time\">" "<\"SCALAR\",\"Physical time\">" 
					  "<\"SCALAR\",\"Physical time\">" "<\"Triad\",10,1,\"TMAT34\",\"Position matrix\">"))
				  (x-oper (list "\"None\"" "\"None\"" "\"None\"" "\"Position X\""))
				  (y-result (list "<\"Torque\",40,1,\"SCALAR\",\"Moment value\">" "<\"Triad\",10,9,\"VEC3\",\"Acceleration\">"
					  "<\"Revolute joint\",21,1,\"SCALAR\",\"Rz joint variables\",\"Angular velocity\">" 
					  "<\"Triad\",10,1,\"TMAT34\",\"Position matrix\">"))
				  (y-object (list "1 FcLOAD" "9 FcTRIAD" "1 FcREV_JOINT" "1 FcTRIAD"))
				  (y-oper (list "\"None\"" "\"X\"" "\"None\"" "\"Position Y\""))
				  (legend "\"Triad [1], Position Y vs Triad [1], Position X\"")
				  (x-object "1 FcTRIAD")
				  )
				 (loop for i from 0 to 3 do
					(setf baseID (1+ baseID))
					(write-curve-sets-to-fmm stream baseID (nth i descr) (1+ i) (1+ i) (nth i x-result) (nth i x-oper) 
						(nth i y-result) (nth i y-object) (nth i y-oper) (if (= i 3) legend) (if (= i 3) x-object))
				 )
			)
		)
		;;If false:
		(progn
			(format stream "END_TIME = 1;~%")
			(format stream "TIME_INCR = 0.01;~%")
			(format stream "MAXIMUM_NUM_IT = 50;~%")
			(format stream "MINIMUM_NUM_IT = 1;~%")
			(format stream "MIN_MATRIX_UPDATES = 5;~%")
			(format stream "MIN_TIME_INCREMENT = 1e-006;~%")
			(format stream "MAX_SEQUENTIAL_NO_MATRIX_UPDATES = 5;~%")
			(format stream "NUM_EIGENMODES = 10;~%")
			(format stream "STATIC_EQL_TOLERANCE = 1e-006;~%")
			(format stream "STEP_REDUCTION_FACTOR = 1;~%")
			(format stream "TOL_DISPLACEMENT_NORM = 1e-006 ALL_OF;~%")
			(format stream "TOL_DISPLACEMENT_ROT = 3e-004 IGNORE;~%")
			(format stream "TOL_DISPLACEMENT_TRA = 1e-004 IGNORE;~%")
			(format stream "TOL_ENERGY_MAX = 0.0001 IGNORE;~%")
			(format stream "TOL_ENERGY_SUM = 1e-006 ALL_OF;~%")
			(format stream "TOL_RESIDUAL_NORM = 1 IGNORE;~%")
			(format stream "TOL_RESIDUAL_ROT = 1 IGNORE;~%")
			(format stream "TOL_RESIDUAL_TRA = 1 IGNORE;~%")
			(format stream "TOL_VELOCITY_NORM = 1e-006 ALL_OF;~%")
			(format stream "TOL_MATRIX_UPDATE_FACTOR = 100;~%")
			(format stream "USE_FIXED_MATRIX_UPDATES = false;~%")
			(format stream "USE_DYN_STRESS_STIFFENING = true;~%")
			(format stream "USE_EIG_STRESS_STIFFENING = true;~%")
			(format stream "USE_EQU_STRESS_STIFFENING = false;~%")
			(format stream "USE_MASS_CORRECTION = true;~%")
			(format stream "AUTO_RBM_ANIMATION = true;~%}~2%")
		) ;;If false end
	)
)

(defun write-engines-to-fmm (stream baseID ID descr sensor math-func entity dof)
	(format stream "ENGINE  {~%")
	(format stream "BASE_ID = ~d;~%" baseID)
	(format stream "ID = ~d;~%" ID)
	(format stream "DESCR = ~a;~%" descr)
	(format stream "SENSOR = ~a;~%" sensor)
	(format stream "MATH_FUNC = ~a;~%" math-func)
	(format stream "ENTITY = ~d;~%" entity)
	(format stream "DOF = ~d;~%}~2%" dof)
)

(defun write-sensors-to-fmm (stream baseID ID descr measured)
	(format stream "SENSOR~%{~%")
	(format stream "BASE_ID = ~d;~%" baseID)
	(format stream "ID = d;~%" ID)
	(format stream "DESCR = ~a;~%" descr)
	(format stream "MEASURED = ~a;~%}~2%" measured)
)

(defun write-control-lines-to-fmm (stream baseID controlID ownerStart ownerEnd ful controlNo)
	(format stream "CONTROL_LINE~%{~%")
	(format stream "BASE_ID = ~d;~%" baseID)
	(format stream "ID = ~d;~%" controlID)
	(format stream "OWNER_START = ~a;~%" ownerStart)
	(format stream "OWNER_END = ~a;~%" ownerEnd)
	(format stream "FIRST_LINE_VERTICAL = 0;~%")
	(format stream "FIRST_UNDEF_LINE = ~d;~%" ful)
	(format stream "SEGMENT_LENGTHS =  0.25;~%")
	(format stream "CONTROL_VAR_NO = ~d;~%}~2%" controlNo)	
)
	


(defun write-control-io-to-fmm (stream name baseID ID engine position &optional (rate nil))
	(format stream "~a;~%{~%" name)
	(format stream "BASE_ID = ~d;~%" baseID)
	(format stream "ID = ~d;~%" ID)
	(format stream "ENGINE = ~a;~%" engine)
	(format stream "POSITION  = ~a;~%" position)
	(format stream "LEFT_ORIENTATED = 0;~%")
	(if rate 
		(format stream "RATE = ~a;~%" rate)
	)
	(format stream "}~3%")
)
	

(defun write-graph-definitions-to-fmm (stream baseID descr ID title)
	(format stream "GRAPH~%{~%")
	(format stream "AUTO_SCALE = true;~%")
	(format stream "BASE_ID = ~d;~%" baseID)
	(format stream "DESCR = \"~a\";~%" descr)
	(format stream "ID = ~d;~%" ID)
	(format stream "TITLE = \"~a\";~%}~2%" title)
)

(defun write-curve-sets-to-fmm (stream baseID descr ID owner x-result x-oper y-result y-object y-oper &optional legend x-object)
	(format stream "CURVE_SET~%{~%")
	(format stream "BASE_ID = ~d;~%" baseID)
	(format stream "DESCR = ~a;~%" descr)
	(format stream "EXPORT_AUTOMATICALLY = true;~%")
	(format stream "ID = ~d;~%" ID)
	(format stream "INPUT_MODE = TEMPORAL_RESULT;~%")
	(if legend 
		(format stream "LEGEND = ~a;~%" legend)
	)
	(format stream "OWNER_GRAPH = ~d;~%" owner)
	(format stream "X_AXIS_RESULT = ~a;~%" x-result)
	(if x-object 
		(format stream "X_AXIS_RESULT_OBJECT = ~a;~%" x-object)
	)
	(format stream "X_AXIS_RESULT_OPER = ~a;~%" x-oper)
	(format stream "Y_AXIS_RESULT = ~a;~%" y-result)
	(format stream "Y_AXIS_RESULT_OBJECT = ~a;~%" y-object)
	(format stream "Y_AXIS_RESULT_OPER = ~a;~%}~2%" y-oper)
)
	

(defun get-rot-axis (constraint)
	(cross-product '(0 0 1) (get-joint-direction-vector constraint))
)	
	
(defun get-rot-angle (constraint)
	(angle-between-2-vectors '(0 0 1) (get-joint-direction-vector constraint))
)

(defun get-unit-vector (constraint)
	(loop for element in (get-rot-axis constraint)
		collect (/ element (vector-length (get-joint-direction-vector constraint)))
	)
)
;;; Writes the mechanism to a simulation file (.fsi)
(define-method write-save-fedem-solver  mechanism-collection ()
  (let (
	  (idcount 10)
        (extidcount 0)
        (superelements nil)
        (triads nil)
        )
    (with-open-file (stream (logical-path (the path (:from !version-selection)) (concatenate "fedem_solver" ".fsi") )
                          :direction :output
                          :if-exists :overwrite
                          )
      (progn
        ;(loop for link in !link-ref-list         
        ;  do
        ;  (setf idcount (1+ idcount))
        ;  (setf extidcount (1+ extidcount))
        ;  (setf superelements (append superelements (list idcount)))
        ;  
        ;  (loop for triad in (the solid-constraints-ref-list (:from link))
        ;    for frame =  (vector-to-list (get-position-matrix (the main-frame (:from triad)) ) )
        ;    when (not (and (equal 0 (the index (:from link))) (equal "open" (superior (the constraint-element (:from triad)))) ))
        ;    do
        ;    (setf idcount (1+ idcount))
        ;    (setf extidcount (1+ extidcount))
        ;    (format stream "~a~%" "&TRIAD")
        ;    (format stream "~t id = ~d~%" idcount)
        ;    (format stream "~t extId = ~d~%" extidcount)
        ;    (format stream "~t nDOFs = ~d~%" (if (equal 0 (the index (:from link))) 0 6) )
        ;    (format stream "~t ur = ~{~{~1,9e ~}~%~6t ~}"  (list (append (subseq frame 0 3) (list (nth 12 frame)))
        ;                                                         (append (subseq frame 4 7) (list (nth 13 frame)))
        ;                                                         (append (subseq frame 8 11) (list (nth 14 frame)))
        ;                                                         ) )
        ;    (format stream "~%/~2%")
        ;    
        ;    and collect idcount into trs
        ;    finally (setf triads (append triads (list trs)))  
        ;    )
        ;  
        ;  )
        (print triads)
        (setf extidcount 0)
        (loop for link in !link-ref-list
          for id = (the index (:from link))
;;;           from 0 to (1- (length !link-ref-list))
          for triader = (nth id triads)
          for frame =  (vector-to-list (get-position-matrix (the main-frame (:from (nth 0 (the solid-constraints-ref-list (:from link)))) ) ) )
          when (not (equal 0 id ) )
          do
          (setf idcount (1+ idcount))
          (format stream "~a~%" "&SUP_EL")
          (format stream "~t id = ~d~%" idcount)
          (format stream "~t extId = ~d~%" id)
          (format stream "~t numGenDOFs = 0~%")
          (format stream "~t numTriads = ~d~%" (length triader))
          (format stream "~t triadIds = ~{~d ~}~%" triader)
          (format stream "~t shadowPosAlg = 1~%")
          (format stream "~t massCorrFlag = -1~%")
          (format stream "~t stiffScale = 1.0~%")
          (format stream "~t massScale = 1.0~%")
          (format stream "~t alpha1 = 0.0, alpha2 = 0.0~%")
          (format stream "~t subPos = ~{~{~1,9e ~}~%~6t ~}"  (list (append (subseq frame 0 3) (list (nth 12 frame)))
                                                                   (append (subseq frame 4 7) (list (nth 13 frame)))
                                                                   (append (subseq frame 8 11) (list (nth 14 frame)))
                                                                                  ) )
          (format stream "~%/~2%")
         ; (print (the solid-constraints-ref-list (:from link)) )
         ; (loop for triad in (the solid-constraints-ref-list (:from link))
         ;   for i = (the index (:from triad) )
;;;      ;       for un_frame = (vector-to-list (matrix-multiply (get-position-matrix (the main-frame (:from triad))) (matrix-inverse frame) ))
         ;   do
         ;   (print i)
         ;   (print triader)
         ;   (format stream "~a~%" "&TRIAD_UNDPOS")
         ;   (format stream "~t supElId = ~d~%" idcount)
         ;   (format stream "~t triadId = ~d~%" (nth i triader) )
;;;      ;       (format stream "~t undPosInSupElSystem = ~{~{~1,9e ~}~%~6t ~}"  (list (append (subseq un_frame 0 3) (list (nth 12 un_frame)))
;;;      ;                                                                             (append (subseq un_frame 4 7) (list (nth 13 un_frame)))
;;;      ;                                                                             (append (subseq un_frame 8 11) (list (nth 14 un_frame)))
;;;      ;                                                                             ) )
         ;   (format stream "~%/~2%")
         ;  )
          )
        )
      )
    )
  )