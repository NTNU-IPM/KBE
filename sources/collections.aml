; Class: collecion-class
; Constructs a generic collecion-class, used by the different collections
;-------------------------------------------------------------------------------------------------------------
(define-class collection-class
  :inherit-from (object)
  :properties (
               collection-type nil
               )
  )

;-----------------------------------------------------
; Checks whether a specific file is accessible or not, 
; if so then the corresponding read method is executed
;-----------------------------------------------------
(define-method read-from-file collection-class ()
  (let (
        (file-name (write-to-string !collection-type ))
        (file-path (logical-path (the version-path (:from ^version-selection)) (concatenate file-name ".txt")))
        (function-name (read-from-string (concatenate "read-" file-name "-from-file")) )
        )
    (if (and
         file-path
         (stringp file-path)
         (probe-file file-path)
         )
        (with-open-file (file file-path :direction :input)
          (apply function-name (list file))
          )
      (progn
        (message (format nil "\"~a\" is not a valid file path." file-path) :append? t)
        nil
        )
      )
    )
  )
;-------------------------------------------------------------------------------------------------------------
; END collecion-class definitions
;-------------------------------------------------------------------------------------------------------------
  
;-------------------------------------------------------------------------------------------------------------
; Class: constraint-class
; Executes the read-from-file method and creates the corresponding subobjects for the constraints
;-------------------------------------------------------------------------------------------------------------  
(define-class constraint-collection
  :inherit-from (series-object collection-class)
  :properties (	
               links-list 		nil ;;Set as link-model-class objects
			   collection-type 	'constraints
               constraint-list 	(cdr (read-from-file !superior))
               quantity 		(length ^constraint-list)
               series-prefix 	'c
               class-expression	'(read-from-string (concatenate 
									(nth 1 (nth !index !constraint-list)) "-constraint-class")) 
									;;The "-constraint-classes" are master-joint-models
			   
			   init-form '(
                           point-ref 			(nth (nth 0 (nth !index ^constraint-list)) ^point-ref-list)
                           label 				(concatenate (nth 1 (nth !index ^constraint-list)) " " (write-to-string (nth 2 (nth !index ^constraint-list))))
						   constraint-type 		(nth 1 (nth !index ^constraint-list))
                           link-incidence 		(nth 2 (nth !index ^constraint-list))
                           direction 			(normalize (nth 3 (nth !index ^constraint-list)))
                           constraint-variable	(nth 4 (nth !index ^constraint-list))
						   incident-links		(let (
													  (link1 (if (first (nth 2 (nth !index ^constraint-list)))
															(nth (first (nth 2 (nth !index ^constraint-list))) ^links-list)
															))
													  (link2 (if (second (nth 2 (nth !index ^constraint-list)))
															(nth (second (nth 2 (nth !index ^constraint-list))) ^links-list)
															))
													  )
													  (remove nil (list link1 link2))
												)
                           )
						   
               property-objects-list (list
									  '("Draw all joints" (button1-parameters :draw-joints )
                                        ui-work-area-action-button-class)
									  '("Draw all joints with mating nodes" (button1-parameters :draw-joints-mesh)
                                        ui-work-area-action-button-class)
										""
										'("Undraw" (button1-parameters :undraw)
                                        ui-work-area-action-button-class)
									  )
			   )
  )
  
(define-method get-constraints constraint-collection ()
	(children (the) :class 'master-joint-model)
)
  
;-------------------------------
; Creates buttons to draw joints
;-------------------------------
(define-method work-area-button1-action constraint-collection (params)
	(case params
		(:draw-joints
			(loop for constraint in (get-constraints (the))
				do 
				(with-error-handler (:error-message (concatenate "Error drawing " (write-to-string 
						(object-name constraint))) :show-system-error? nil)
					(let (
							(male (the male-joint-element (:from constraint)))
							(female (the female-joint-element (:from constraint)))
						)
						(progn
							(if male (progn 
								(change-value (the display? (:from (the rbe2-independent-node (:from male)))) nil)
								(change-value (the display? (:from (the rbe2-dependent-nodes (:from male)))) nil)
								))
							(if female (progn
								(change-value (the display? (:from (the rbe2-independent-node (:from female)))) nil)
								(change-value (the display? (:from (the rbe2-dependent-nodes (:from female)))) nil)
								))
						)
					)
				(draw constraint))
			)
		)
		(:draw-joints-mesh
			(loop for constraint in (get-constraints (the))
				do 
				(with-error-handler (:error-message (concatenate "Error drawing " (write-to-string 
						(object-name constraint))) :show-system-error? t)
					(let (
							(male (the male-joint-element (:from constraint)))
							(female (the female-joint-element (:from constraint)))
						)
						(progn
							(if male (progn 
								(change-value (the display? (:from (the rbe2-independent-node (:from male)))) t)
								(change-value (the display? (:from (the rbe2-dependent-nodes (:from male)))) t)
								))
							(if female (progn
								(change-value (the display? (:from (the rbe2-independent-node (:from female)))) t)
								(change-value (the display? (:from (the rbe2-dependent-nodes (:from female)))) t)
								))
						)
					)
				(draw constraint))
			)
		)
		(:undraw
			(undraw self)
		)
	)  
)
;-------------------------------------------------------------------------------------------------------------
; END constraint-collection definitions
;-------------------------------------------------------------------------------------------------------------

;-------------------------------------------------------------------------------------------------------------
; Class: point-collection
; Executes the read-from-file and creates the corresponding subobjects for the points
;-------------------------------------------------------------------------------------------------------------
(define-class point-collection
  :inherit-from (series-object collection-class)
  :properties (
               collection-type 	'coordinates
               points-list 		(cdr (read-from-file !superior))
               quantity 		(length ^points-list)
               class-expression	'point-data-model
               series-prefix 	'p
               init-form '(
						   label 		(nth 0 (nth ^index ^points-list))
                           coordinates	(list (nth 1 (nth ^index ^points-list)) (nth 2 (nth ^index ^points-list)) (nth 3 (nth ^index ^points-list)))
						   dv-values 	(nth 4 (nth ^index ^points-list))
						   line-group 	(nth 5 (nth ^index ^points-list))
						   is-fixed? 	(nth 6 (nth ^index ^points-list))
						   id 			^index
                           )
               )
  )

(define-method get-points point-collection ()
	(children (the) :class 'point-data-model)
)
;-------------------------------------------------------------------------------------------------------------
; END point-collection definitions
;-------------------------------------------------------------------------------------------------------------
  
;-------------------------------------------------------------------------------------------------------------
; Class: shape-collection
; Executes the read-from-file method and creates the corresponding subobjects for the shapes
;-------------------------------------------------------------------------------------------------------------
(define-class shape-collection
  :inherit-from (series-object collection-class)
  :properties (
               collection-type 'shapes
               shapes-list (cdr (read-from-file !superior))
               quantity (length ^shapes-list)
               class-expression 'shape-model
               series-prefix 'shape
               init-form '(
						   label 				(nth 0 (nth ^index ^shapes-list))
                           link-ref 			(nth 1 (nth ^index ^shapes-list))
                           sweep-index 			(nth 2 (nth ^index ^shapes-list))
                           cross-section-type 	(nth 3 (nth ^index ^shapes-list))
                           solid-dimensions 	(if (not (nth 4 (nth ^index ^shapes-list)))
													(list 0 0)
													(nth 4 (nth ^index ^shapes-list))
													)
                           point-list 			(nth 5 (nth ^index ^shapes-list))
                           weight-list 			(nth 6 (nth ^index ^shapes-list))
                           )
               )
  )

(define-method get-input-shapes shape-collection ()
	(children (the) :class 'shape-model)
)
;-------------------------------------------------------------------------------------------------------------
; END shape-collection definitions
;-------------------------------------------------------------------------------------------------------------

;-------------------------------------------------------------------------------------------------------------
; Class: link-collection
; Creates all the links in the object tree
;-------------------------------------------------------------------------------------------------------------
(define-class link-collection
  :inherit-from (series-object)
  :properties (
               constraints-list 	nil ;;List of all master-joint-models in the mechanism
			   input-shapes-list	nil ;;List of all initial shape-models
			   (cross-section-type :class 'option-property-class
                   label "Cross-section Type"
                   mode 'menu
                   formula (nth 0 !options-list)
				   
				   ;Returns all classes that inherits from cross-section-model, i.e. all cross-sections
                   options-list (reverse (class-direct-defined-subclasses 'cross-section-model))
                   labels-list (loop for option in !options-list
                                 collect (remove "-section" (write-to-string option))
                                 )
                   )
               common-width 0.04
               common-height 0.04
               property-objects-list (list
					(list (the superior cross-section-type self) 
					'(automatic-apply? t))
					'("Set all cross-sections" (button1-parameters :set-c button3-parameters :unset)
					ui-work-area-action-button-class)
					
					(list (the superior common-width self)
					'(automatic-apply? t))
					(list (the superior common-height self) 
					'(automatic-apply? t))
					'("Set all dimensions" (button1-parameters :set-d button3-parameters :unset)
					ui-work-area-action-button-class)
					""
					'("Draw all link members" (button1-parameters :draw-without-mesh button3-parameters :draw-without-mesh)
					ui-work-area-action-button-class)
					'("Draw all link members with mesh" (button1-parameters :draw-with-mesh button3-parameters :draw-with-mesh)
					ui-work-area-action-button-class)
					""
					'("Undraw" (button1-parameters :undraw button3-parameters :unset)
					ui-work-area-action-button-class)
				)

				;;Returns a sorted list of all link numbers in the mechanism. I.e: (0 1 2 3 4)
				link-list (sort (remove nil (copy-seq (remove-duplicates (append-list (loop for constraint in ^constraints-list
                                                                 collect (the link-incidence (:from constraint)) 
                                                                 )
                                                               ))
                                        )) '<)
										
               (init-default-shape :class 'shape-model
                   )
               
               ;;; 
			   default-shape (let(
                                  (def (loop for shape in ^input-shapes-list
                                         when (equal 'default (the link-ref (:from shape)))
                                         do (return shape)
                                         ) )
                                  )
                               (if def def ^init-default-shape)
                               )
							   
               shape-list (remove-duplicates (loop for kid in (the shapes-ref-list)
								collect (list (the label (:from kid)) (the link-ref (:from kid)))
							))
							
			   quantity (length ^link-list)
               class-expression 'link-model-class
               series-prefix 'link
               init-form '(
                           link-index (nth ^index ^^link-list)
                           label (let(
									  (shape-name (loop for shape in ^shape-list
										if (equal ^index (nth 1 shape))
											do (return (nth 0 shape)))
									   )
									 )
									(if (equal shape-name nil) 
										(concatenate "Link-" (write-to-string !index))
										(concatenate (write-to-string !index) " " (write-to-string shape-name))
									)
							   )
						   constraints-incident-on-link-list (loop for constraint in ^constraints-list
                                                               for con = (get-constraint-incidence constraint (the superior))
                                                               when con collect con
                                                               )
                           )
               )
  )
  
(define-method get-links link-collection ()
	(children (the) :class 'link-model-class)
)
  
;-----------------------------------------------
; Gets the link reference from a link-collection
;-----------------------------------------------
(define-method get-link-ref link-collection (link-index)
  (nth (position link-index !link-list) ^link-ref-list)
  )
  
;--------------------------------------------------------------------
; Button actions for drawing/undrawing links (with and without mesh),
; setting cross-section-type and setting dimensions  
;--------------------------------------------------------------------
(define-method work-area-button1-action link-collection (params)
	(case params
		(:set-c
			(loop for l in ^link-ref-list do
				(loop for s in (the members-ref-list (:from (the link-geometry (:from l)) )) do
					(change-value (the cross-section-type self (:from s)) !cross-section-type)
				)
			)
		)
		(:set-d
			(loop for l in ^link-ref-list
				do (loop for s in (the members-ref-list (:from (the link-geometry (:from l)) ))
					do (progn
					(change-value (the width self (:from s)) !common-width)
					(change-value (the height self (:from s)) !common-height)
					(change-value (the width-end self (:from s)) !common-width)
					(change-value (the height-end self (:from s)) !common-height)
					)
				)
			)
		)
		(:draw-without-mesh
			(loop for link in ^link-ref-list
				do (loop for member in (the visible-members-ref-list (:from (the link-geometry (:from link)) ))
					do (draw member :draw-subobjects? nil )
				)
			)
		)
		(:undraw
			(undraw self)
		)
		(:draw-with-mesh
			(draw self)
		)
	)
	
)
;-------------------------------------------------------------------------------------------------------------
; END link-collection definitions
;-------------------------------------------------------------------------------------------------------------

;-------------------------------------------------------------------------------------------------------------
; Class: spring-damper-collection
;-------------------------------------------------------------------------------------------------------------
(define-class spring-damper-collection
	:inherit-from (series-object collection-class)
	:properties (
				 points-list		nil
				 collection-type 	'spring-damper
				 sd-list 			(cdr (read-from-file !superior)) ;;Called on the collection-class
				 quantity			(length ^sd-list)
				 class-expression	'(read-from-string (format nil "~a-model-class"
										(nth 0 (nth !index !sd-list)))) 
				 init-form '(
							 label 			(format nil "~a" (nth 0 (nth ^index ^sd-list)))
							 from-point		(nth (nth 1 (nth ^index ^sd-list)) ^points-list)
							 to-point		(nth (nth 2 (nth ^index ^sd-list)) ^points-list)
							 ground-point	(if (nth 3 (nth ^index ^sd-list))
												(nth (nth 3 (nth ^index ^sd-list)) ^points-list)
												nil
											)
							 )
				 )
)

(define-method get-springs spring-damper-collection ()
	(children (the) :class 'spring-model-class)
)

(define-method get-dampers spring-damper-collection ()
	(children (the) :class 'damper-model-class)
)
;-------------------------------------------------------------------------------------------------------------
; END spring-damper-collection definitions
;-------------------------------------------------------------------------------------------------------------

;-------------------------------------------------------------------------------------------------------------
; Class: load-collection
; Class to add loads as subobjects (load-model)
;-------------------------------------------------------------------------------------------------------------
(define-class load-collection
	:inherit-from (object)
	:properties (
				 mech-size nil
				 (type :class 'option-property-class
					mode 			'radio
					options-list	(list 'force 'torque)
					formula 		'torque
					label 			"Load type"
					)
				 (point :class 'editable-data-property-class
					formula (default '(0 0 0))
					label "Load point"
					)
				 (magn :class 'var-unit-data-property-class
					current-load (case ^^type
									('force 'N)
									('torque (progn (add-unit 'Nm 1.0 '(N m)) 'Nm))
								  )
					value-in 	1
					unit-in 	^current-load
					unit 		^current-load
					label 		"Magntitude"
					)
			     (direction :class 'editable-data-property-class
					formula 	(default '(1 0 0))
					label 		"Load direction vector"
					)
				 (load-name :class 'editable-data-property-class
					formula (concatenate "Load-" (write-to-string (1+ (length (children (the superior))))))
					label 	"Load name"
					)
				 
				 (load-case :class 'load-model
					load-type ^^type
					load-point ^^point
					magnitude ^^magn
					load-direction ^^direction
					)
				 				 
				 init-form '(
							load-type 		^type
							load-point 		^point
							magnitude 		^magn
							load-direction 	^direction
							mechanism-size	^mech-size
							)
				
				 property-objects-list (list
										(list (the superior type self)
											'(automatic-apply? t))
										(list (the superior point self)
											'(automatic-apply? t))
										(list (the superior magn self)
											'(automatic-apply? t))
										(list (the superior direction self)
											'(automatic-apply? t))
										(list (the superior load-name self)
											'(automatic-apply? t))
										'("Apply load" (button1-parameters :apply-load)
											ui-work-area-action-button-class)
					)
				 )
)

(define-method work-area-button1-action load-collection (params)
	(case params
		(:apply-load
			(if (equal "Yes" (pop-up-message (format nil "Are these settings OK?~%Load type: ~a~%Magnitude: ~a~%Direction: ~a" 
					!type !magn !direction) :width 200 :done-label "Yes" :cancel-label "No"))
				(progn
					(add-subobject-to-data-model-node (the) (read-from-string !load-name) 'load-model 
						:init-form !init-form
					)
					(draw self :draw-subobjects? t)
				)
			)
		)
	)
)

;-------------------------------------------------------------------------------------------------------------
; Class: folder-collection
; Reads all subfolders of the library folder in the file system and creates a subobject for each folder 
; as a series-object of the type folder-info-model
;-------------------------------------------------------------------------------------------------------------
(define-class folder-collection
  :inherit-from (series-object)
  :properties (
               ;; Removing ../ and ./
			   ;; Returns a list of the contents in the library directory
               library-subfolder-list (rest (rest (directory #mechanism-library#)) )
               quantity (length ^library-subfolder-list)
               class-expression 'folder-info-model
               series-prefix 'folder
               init-form '(
                           path (nth ^index ^^library-subfolder-list)
                           )
               )
  )
;-------------------------------------------------------------------------------------------------------------
; END folder-collection definitions
;------------------------------------------------------------------------------------------------------------- 

;-------------------------------------------------------------------------------------------------------------
; Class: design-variables-collection
;-------------------------------------------------------------------------------------------------------------
(define-class design-variables-collection 
	:inherit-from (series-object collection-class)
	:properties (
				 collection-type 'design-variables
				 dv-list (read-from-file !superior)
				 quantity (length ^dv-list)
				 series-prefix 'dv
				 class-expression 'design-variable-class
				 init-form '(
							 type (nth 0 (nth ^index ^dv-list))
							 dv-name (nth 0 (nth ^index ^dv-list))
							 direction (nth 1 (nth ^index ^dv-list))
							 ;; TODO: Handle the possibility of more than one group of points on a line
							 line-name (nth 0 (remove-duplicates (remove nil 
												(loop for point-entry in ^^point-ref-list
													if (the dv-values (:from point-entry)) 
														append (loop for dv in (the dv-values (:from point-entry))
															if (and (string-equal (string dv) (string ^dv-name)) (the line-group (:from point-entry)))
																collect (the line-group (:from point-entry))
															)
														)
													)
												))
											
							 points-on-line (remove nil 
												(loop for point-entry in ^^point-ref-list
													if (string-equal ^line-name (the line-group (:from point-entry)))
														collect (list (the id (:from point-entry)) (the is-fixed? (:from point-entry)) )
													)
												)
												
							 affected-translation-coords-list 
									(remove nil (loop for point-entry in ^^point-ref-list
										if (the dv-values (:from point-entry))
											 append (loop for dv in (the dv-values (:from point-entry))
												if (string-equal (string dv) (string ^dv-name))
													collect (the id (:from point-entry))
												 )
										)
									)
                             )
				 )
	 )	 
;-------------------------------------------------------------------------------------------------------------
; END design-variables-collection definitions
;-------------------------------------------------------------------------------------------------------------  

;-----------------------------------------------------------
; Reads each line of the shapes file and adds this to a list
;-----------------------------------------------------------
(defun read-shapes-from-file (stream)
 (when stream
   (loop for line = (read-line stream  nil :eof)
     until (equal line :eof)
     for ls = (string-to-delimited-token-list line :delimiter #\tab :string-token? nil)
     for shape-data = (list
                       (read-from-string(nth 0 ls)) (nth 1 ls) (nth 2 ls) (read-from-string (nth 3 ls)) (read-from-string (nth 4 ls)) (read-from-string (nth 5 ls)) (read-from-string (nth 6 ls))
                       )
     collect shape-data
     )
   )
 )
 
;----------------------------------------------------------------
; Reads each line of the constraints file and adds this to a list 
;----------------------------------------------------------------
(defun read-constraints-from-file (stream)
  (when stream
    (loop for line = (read-line stream nil :eof)
      until (equal line :eof)
      for ls = (string-to-delimited-token-list line :delimiter #\tab :string-token? nil)
      for c-data = (list
                    (nth 0 ls) (nth 1 ls) (read-from-string (nth 2 ls)) (read-from-string (nth 3 ls)) (read-from-string (nth 4 ls))
                    )
      collect c-data
      )
    )
  )


  
;---------------------------------------------------------------
; Reads each line of the coordinats file and adds this to a list
;---------------------------------------------------------------
(defun read-coordinates-from-file (stream)
  (when stream
    (loop for line = (read-line stream nil :eof)
      until (equal line :eof)
	  for ls = (string-to-delimited-token-list line :delimiter #\tab :string-token? nil)
	  for coord-line = (list
		(read-from-string (nth 1 ls)) (nth 2 ls) (nth 3 ls) (nth 4 ls) (read-from-string (nth 5 ls)) (read-from-string (nth 6 ls)) (nth 7 ls) )
      collect coord-line
      )
    )
  )
  
;---------------------------------------------------------------------
; Reads each line of the design-variables file and adds this to a list
;---------------------------------------------------------------------  
(defun read-design-variables-from-file (stream)
	(when stream
		(loop for line = (read-line stream  nil :eof)
			until (equal line :eof)
			for ls = (string-to-delimited-token-list line :delimiter #\tab :string-token? nil)
			for design-data = (list (read-from-string (nth 0 ls)) (read-from-string (nth 1 ls)) )
			collect design-data
			)
		)
   )
  
;------------------------------------------------------------------
; Reads each line of the spring-damper file and adds this to a list
;------------------------------------------------------------------
(defun read-spring-damper-from-file (stream)
	(when stream
		(loop for line = (read-line stream  nil :eof)
			until (equal line :eof)
			for ls = (string-to-delimited-token-list line :delimiter #\tab :string-token? nil)
			for data = (list (read-from-string (nth 0 ls)) (nth 1 ls)  (nth 2 ls) (nth 3 ls))
			collect data
			)
		)
)
;-------------------------------------------------------------------------------------------------------------
; Class: folder-info-model
; Defines the data-model for folders
;-------------------------------------------------------------------------------------------------------------
(define-class folder-info-model
  :inherit-from (series-object)
  :properties (
               path nil
               folder (subseq (remove #MECHANISM-LIBRARY# ^path) 1)
               label (replace (copy-seq ^folder) " " :start1 (position "-" ^folder :test 'string-equal) )

               class-name (let (
                                (name (read-from-string (concatenate ^folder "-class" ) ))
                                )
                            (when (find-class name)
                              name
                              )
                            )
				
				version-list (rest (rest (directory ^path)))
				class-expression 'mechanism-version-info
				series-prefix 'version
				quantity (length ^version-list)
				init-form '(
							version-path (nth ^index ^^version-list)
							version-name (subseq (remove ^^path ^version-path) 1)
						    )
               )
  )
;-------------------------------------------------------------------------------------------------------------
; END folder-info-model definitions
;------------------------------------------------------------------------------------------------------------- 

;-------------------------------------------------------------------------------------------------------------
; Class: mechanism-version-info
;-------------------------------------------------------------------------------------------------------------
(define-class mechanism-version-info 
	:inherit-from (object)
	:properties (
				 version-path nil				 
				 version-name nil
				 )
	)
;-------------------------------------------------------------------------------------------------------------
; END mechanism-version-info definitions
;-------------------------------------------------------------------------------------------------------------   

;-------------------------------------------------------------------------------------------------------------
; Class: design-variable-class
;-------------------------------------------------------------------------------------------------------------
(define-class design-variable-class
	:inherit-from (object)
	:properties (
				 dv-name nil
				 direction nil
				 line-name nil
				 points-on-line nil
				 affected-translation-coords-list nil
				 coord-pos (position 1 ^direction)
				 
				 (dv-value :class 'editable-data-property-class
					formula (nth ^coord-pos (the coordinates (:from  (nth (nth 0 ^affected-translation-coords-list) ^point-ref-list))))
					label ^dv-name
					)
				 
				 property-objects-list (list 
										 (list (the superior dv-value self)
												'(automatic-apply? t))
										 '("Update design variable changes" (button1-parameters :update-dvs)
											ui-work-area-action-button-class)
										)
				 )
	)
	
(define-method work-area-button1-action design-variable-class (params)
	(case params
		(:update-dvs
			(progn 
				(loop for id in !affected-translation-coords-list do 
					(setq (nth !coord-pos (the coordinates (:from (nth id ^point-ref-list)))) !dv-value)
				)
				(loop for id in !points-on-line do
					;(setq (the coordinates (:from (nth id ^point-ref-list))) )
				)
			)
		)
	)
)
;-------------------------------------------------------------------------------------------------------------
; END design-variable-class definitions
;------------------------------------------------------------------------------------------------------------- 

(defun get-new-dv-coords-from-line (fixed-point dv1 dv2 direction)
	(if (= (nth 0 direction) 1)
		(list 
		 (+ (nth 0 dv1) (* (/ (- (nth 0 fixed-point) (nth 0 dv1)) (- (nth 1 fixed-point) (nth 1 dv1)) ) (- (nth 1 dv2) (nth 1 dv1)) ))
		 (nth 1 dv2)
		 (nth 2 dv2)
		)
		(list
		 (nth 0 dv2)
		 (+ (nth 1 dv1) (* (/ (- (nth 1 fixed-point) (nth 1 dv1)) (- (nth 0 fixed-point) (nth 0 dv1)) ) (- (nth 0 dv2) (nth 0 dv1)) ))
		 (nth 2 dv2)
		)
	)
)

;-------------------------------------------------------------------------------------------------------------
; Class: main-mechanism-class
; Initiates the system by creating all the collections
;-------------------------------------------------------------------------------------------------------------
(define-class main-mechanism-class
  :inherit-from (object)
  :properties (			   
			   point-ref-list (children ^points :class 'point-data-model )
					
			   constraints-ref-list (children ^constraints :class 'master-joint-model)
			   shapes-ref-list (children ^shapes :class 'shape-model)
               link-ref-list (children ^links :class 'link-model-class)
			   
			   final-link-ref-list (loop for link in ^link-ref-list
										if (are-all-members-displayed? link)
											collect link)
											
			   non-free-constraints-list (loop for constraint in (get-constraints ^constraints) do
											  if (not (string-equal "free" (get-constraint-type constraint)))
												  collect constraint)
			   
			   dv-ref-list (children ^design-variables :class 'design-variable-class)
			   
			   ;; mechanism-selection is a list of folder-info-models
               (mechanism-selection :class 'option-property-class
                   labels-list (loop for subfolder in (children ^folders :class 'folder-info-model)
                                when (the path (:from subfolder))
                                collect (the label (:from subfolder))
                                )
                   options-list (children ^folders :class 'folder-info-model)
                   mode 'menu
                   formula (nth (position "four bar" !labels-list) !options-list)
				   label "Select Mechanism"
                   )
				   
			   (version-selection :class 'option-property-class
					options-list (children ^^mechanism-selection :class 'mechanism-version-info)
					labels-list (loop for version in !options-list
									collect (the version-name (:from version))
									)
					mode 'menu
					formula (nth 0 !options-list)
					;formula (nth (- (length !options-list) 1) !options-list)
					label "Select Version"
					)
					
			   (dv :class 'data-matrix-property-class
					label "Edit design variables"
					mode 'pop-up
					columns-labels-list (list "Value")
					rows-labels-list (loop for dv in ^dv-ref-list
						collect (string (the dv-name (:from dv)))
						)
					formula (loop for dv in ^dv-ref-list
						collect (list (the dv-value (:from dv)))
						)
					)
			   
			   
			   property-objects-list (list 
											(list (the superior mechanism-selection self) 
												'(automatic-apply? t))
											(list (the superior version-selection self) 
												'(automatic-apply? t))
											""
											'("Draw mechanism" (button1-parameters :draw-sewn-wo-mesh)
											ui-work-area-action-button-class)
											'("Draw mechanism with 3D mesh" (button1-parameters :draw-sewn-with-tet-mesh)
											ui-work-area-action-button-class)
											'("Draw mechanism with 2D mesh" (button1-parameters :draw-sewn-with-tri-mesh)
											ui-work-area-action-button-class)
											""
											'("Undraw" (button1-parameters :undraw button3-parameters :unset)
											ui-work-area-action-button-class)
											""
											'("Create .bdf-files" (button1-parameters :create-bdf)
											ui-work-area-action-button-class)
											'("Export to FEDEM" (button1-parameters :export-fedem)
											ui-work-area-action-button-class)												
                                     )
               
               ;;Property storing folders from library
               (folders :class 'folder-collection
                   )
				
			   loads-list '() ;; When a user creates a load, it will be added here
			   
			   dv1 (the test-dv (:from (nth 1 ^point-ref-list)))
			   dv2 (the test-dv (:from (nth 3 ^point-ref-list)))
			   			   
			   objective-function (when (probe-file "C:\\Users\\ander_000\\Documents\\KBE\\rasmus\\library\\four-bar\\line\\dummy.txt")
									(+ (the coord-ref (:from (nth 1 ^point-ref-list))) (the coord-ref (:from (nth 3 ^point-ref-list))))
									)
			   
			   mechanism-type (the folder (:from ^mechanism-selection))
               )
  :subobjects (
               (constraints :class 'constraint-collection
				   links-list (get-links ^links)
                   )
               (points :class 'point-collection
                   )
			   (links :class 'link-collection
                   constraints-list 	(get-constraints ^constraints)
				   input-shapes-list	(get-input-shapes ^shapes)
				   )
			   (shapes :class 'shape-collection
                   )
               (design-variables :class 'design-variables-collection
					)
               (spring-dampers :class 'spring-damper-collection
					points-list (get-points ^^points)
					)
			   (loads :class 'load-collection
					mech-size (calculate-mechanism-size ^superior)
					)
			   (mesh-database :class 'meshdb-class
                   )
               )
  )
;-------------------------------------------------------------------
; Adds a load-model object to the loads-list in main-mechanism-class  
;-------------------------------------------------------------------
(define-method add-load main-mechanism-class (load)
	(change-value !loads-list (append !loads-list (list load)))
)

;---------------------------------------------------
; Returns the greatest distance within the mechanism
;---------------------------------------------------
(define-method calculate-mechanism-size main-mechanism-class ()
	(let (
		 (max-x 0)
		 (max-y 0)
		 (max-z 0)
		)
	   (loop for point in !point-ref-list do
		 (progn
			 (if (> (abs (nth 0 (the coordinates (:from point)))) max-x)
				(setf max-x (abs (nth 0 (the coordinates (:from point)))))
			 )
			 (if (> (abs (nth 1 (the coordinates (:from point)))) max-y)
				(setf max-y (abs (nth 1 (the coordinates (:from point)))))
			 )
			 (if (> (abs (nth 2 (the coordinates (:from point)))) max-z)
				(setf max-z (abs (nth 2 (the coordinates (:from point)))))
			 )
		 )
		 finally (return (sqrt (+ (expt max-x 2) (expt max-y 2) (expt max-z 2))))
	   )
	)
)

(define-method get-all-joint-elements main-mechanism-class ()
	(remove nil
		(loop for constraint in (get-constraints !constraints) 
			append (list (get-male-element constraint) (get-female-element constraint))
		)
	)
)

;-----------------------------------------------------------------------------
; Assigns a unique ID (starting from 1) to each joint element in the mechanism
;-----------------------------------------------------------------------------
(define-method get-joint-ID main-mechanism-class (joint-element)
	(1+ (position joint-element (get-all-joint-elements (the))))
)

(define-method get-constraint main-mechanism-class (constraint-number)
	(nth constraint-number !constraints-ref-list)
)
 
(define-method get-mechanism-type main-mechanism-class ()
	(the mechanism-selection label)
)

;-------------------------------------------------
; Creates buttons to draw and export the mechanism 
;-------------------------------------------------
(define-method work-area-button1-action main-mechanism-class (params)
	(case params
		(:draw-sewn-wo-mesh
			(loop for link in !final-link-ref-list do
				(with-error-handler (:error-message (concatenate "Error drawing "(write-to-string (object-name link))) :show-system-error? t)
					(draw (the link-geometry (:from link)) :draw-subobjects? nil)
				)
			)
		)
		(:draw-sewn-with-tet-mesh
			(loop for link in !final-link-ref-list do
				(with-error-handler (:error-message (concatenate "Error drawing "(write-to-string (object-name link))) :show-system-error? t)
					(draw (the link-mesh-model tet-mesh elements-query (:from link)))
				)
			)
		)
		(:draw-sewn-with-tri-mesh
			(loop for link in !final-link-ref-list do
				(with-error-handler (:error-message (concatenate "Error drawing "(write-to-string (object-name link))) :show-system-error? t)
					(draw (the link-mesh-model link-mesh elements-query (:from link)))
				)
			)
		)
		(:undraw
			(undraw self)
		)
		(:create-bdf
			(if (equal "2D" (pop-up-message (format nil "Export to .bdf")
				:width 200 :done-label "2D" :cancel-label "3D")) ;; The pop-up-message returns the selected label
				(loop for link in !final-link-ref-list do
					(change-value (the analysis export-surface? (:from link)) t)
				)
				(loop for link in !final-link-ref-list do
					(change-value (the analysis export-surface? (:from link)) nil)
				)
			)
			(write-nastran-bdf-files (the))
		)
		(:export-fedem
			(write-fmm-model-file (the))
		)
	)
)
;-------------------------------------------------------------------------------------------------------------
; END main-mechanism-class definitions
;-------------------------------------------------------------------------------------------------------------

;----------------------------------------------------------------
; Sets faceting value, which is how fine the geometry is rendered
; ps: effects only the visual representation - not mesh
;----------------------------------------------------------------
(set-faceting 0.04)